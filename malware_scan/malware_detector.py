import os
import joblib
import pandas as pd
from pathlib import Path
from malware_scan.extract_pdf_features import extract_features_from_pdf

# Get the directory containing the current script (malware_detector.py)
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
# Join the directory path with the filename
model_path = os.path.join(BASE_DIR, "demo_xgb_model.pkl")
columns_path = os.path.join(BASE_DIR, "demo_xgb_columns.pkl")

# Load the model using the full, calculated path
model = joblib.load(model_path)
columns = joblib.load(columns_path)

def is_pdf_file(filepath):
    """
    检查文件是否为PDF文件
    通过文件扩展名和文件头部魔数双重验证
    """
    print(f"[DEBUG] Checking if file is PDF: {filepath}")
    
    # 检查文件扩展名
    file_extension = str(filepath).lower()
    has_pdf_extension = file_extension.endswith('.pdf')
    print(f"[DEBUG] File extension check - has .pdf extension: {has_pdf_extension}")
    
    if not has_pdf_extension:
        print(f"[DEBUG] File extension '{Path(filepath).suffix}' is not .pdf - not a PDF file")
        return False
    
    # 检查文件头部是否为PDF魔数
    try:
        with open(filepath, 'rb') as f:
            header = f.read(4)
            is_pdf_header = header == b'%PDF'
            print(f"[DEBUG] File header check - first 4 bytes: {header}")
            print(f"[DEBUG] File header check - is PDF magic number: {is_pdf_header}")
            
            if is_pdf_header:
                print(f"[DEBUG] ✅ File confirmed as PDF (extension + header match)")
                return True
            else:
                print(f"[DEBUG] ❌ File has .pdf extension but wrong header - may be encrypted/corrupted PDF")
                # 对于加密的PDF文件，我们仍然应该检测它们
                # 因为它们仍然是PDF文件，只是被前端加密了
                return True  # 改为True，因为扩展名是.pdf就应该当作PDF处理
                
    except Exception as e:
        print(f"[ERROR] Unable to read file header for {filepath}: {e}")
        # 如果无法读取文件头，但扩展名是.pdf，我们仍然当作PDF处理
        if has_pdf_extension:
            print(f"[DEBUG] Cannot read header but extension is .pdf - treating as PDF")
            return True
        return False

def scan_file(filepath):
    """
    智能文件扫描函数：
    - 只对PDF文件进行恶意软件检测
    - 非PDF文件直接放行
    - PDF文件检测阈值提高到0.98
    """
    print(f"[INFO] Starting scan for file: {filepath}")
    
    # 检查是否为PDF文件
    if not is_pdf_file(filepath):
        file_ext = Path(filepath).suffix.lower()
        print(f"[INFO] Non-PDF file detected (extension: {file_ext}). Skipping malware scan - file approved.")
        return 0, 0.0  # 非PDF文件直接放行，返回安全状态
    
    print(f"[INFO] PDF file confirmed. Running malware detection...")
    
    # 对PDF文件进行恶意软件检测
    try:
        prediction, score = scan_pdf(filepath)
        print(f"[INFO] PDF scan completed - Raw prediction: {prediction}, Raw score: {score}")
        
        # 设置更严格的阈值：只有当score > 0.98时才判定为恶意
        MALWARE_THRESHOLD = 0.98
        
        if score > MALWARE_THRESHOLD:
            print(f"[WARNING] Malicious PDF detected! Score {score} exceeds threshold {MALWARE_THRESHOLD}")
            return 1, score  # 恶意文件
        else:
            print(f"[INFO] PDF file appears safe. Score {score} is below threshold {MALWARE_THRESHOLD}")
            return 0, score  # 安全文件
            
    except Exception as e:
        print(f"[ERROR] Error during PDF scanning: {e}")
        # 扫描出错时，为了安全起见，可以选择：
        # 1. 放行文件 (return 0, 0.0)
        # 2. 阻止文件 (return 1, 1.0) 
        # 3. 抛出异常让上层处理
        # 这里选择放行，但记录错误
        print(f"[INFO] Due to scan error, allowing file to pass for manual review")
        return 0, 0.0

def scan_pdf(filepath):
    """
    原始的PDF扫描函数
    """
    features = extract_features_from_pdf(filepath, columns)
    df = pd.DataFrame([features]).reindex(columns=columns, fill_value=0)
    prediction = model.predict(df)[0]
    proba = model.predict_proba(df)[0][1]  # probability of malicious
    return prediction, proba