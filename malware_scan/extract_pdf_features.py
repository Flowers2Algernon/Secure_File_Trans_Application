

import os
import re
import traceback # Import traceback for better error logging
import subprocess
# Get the directory containing this script (extract_pdf_features.py)
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))

def extract_features_from_pdf(filepath, training_columns, parser_script_name="pdf-parser.py"):
    """
    Extracts features from a PDF file using an external parser script.
    """
    features = dict.fromkeys(training_columns, 0)

    # Construct the full path to the pdf-parser.py script
    # Assumes pdf-parser.py is in the SAME directory as this script
    parser_full_path = os.path.join(SCRIPT_DIR, parser_script_name)

    # --- Define the CORRECT Python executable path ---
    python_executable = "/home/ubuntu/fullstack/venv/bin/python"

    try:
        # --- Basic checks before running subprocess ---
        if not os.path.exists(python_executable):
            raise FileNotFoundError(f"Python executable not found at {python_executable}")
        if not os.path.exists(parser_full_path):
             raise FileNotFoundError(f"Parser script not found at {parser_full_path}")
        if not os.path.exists(filepath):
             raise FileNotFoundError(f"Input PDF file not found at {filepath}")

        print(f"Attempting to run parser: {python_executable} {parser_full_path} {filepath}") # Debug print

        result = subprocess.run(
            [python_executable, parser_full_path, filepath], # <-- Use corrected paths
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE, # Capture stderr for better debugging
            text=True,
            timeout=15, # Slightly increased timeout
            check=False # Don't automatically raise error on non-zero exit (handle below)
        )

        # --- Check the result of the subprocess ---
        if result.returncode != 0:
            # Log stderr if the parser script failed
            print(f"[!] Parser script failed for {filepath} (Exit Code: {result.returncode})")
            print(f"[!] Parser stderr: {result.stderr}")
            # Depending on requirements, you might want to:
            # 1. Return features indicating an error
            # 2. Raise a custom exception to be handled by the view
            # 3. Continue (as the original code did, might be risky)
            # For now, we log and continue, but consider raising an exception.
            # raise RuntimeError(f"pdf-parser.py failed: {result.stderr}")

        # Process stdout if the command ran (even if it returned errors)
        output = result.stdout.lower() if result.stdout else ""

        # --- Feature extraction logic (remains the same) ---
        keywords = ['obj', 'endobj', 'stream', 'endstream', 'xref', 'trailer',
                    'startxref', '/encrypt', '/js', '/javascript', '/aa',
                    '/openaction', '/acroform', '/jbig2decode', '/richmedia',
                    '/launch', '/embeddedfile', '/xfa']

        for key in keywords:
            try:
                 # Use try-except for regex in case of unexpected output format
                 count = len(re.findall(re.escape(key), output))
                 fname = key.strip('/')
                 if fname in features:
                     features[fname] = count
            except Exception as regex_err:
                 print(f"[!] Regex error processing key '{key}' in output for {filepath}: {regex_err}")


        features['pdfsize'] = os.path.getsize(filepath) # Already checked filepath exists

    except FileNotFoundError as fnf_error:
        # Catch missing python executable or parser script
        print(f"[!] Configuration Error: {fnf_error}")
        # Re-raise so the calling view knows this is a server issue (should be 500)
        raise fnf_error from fnf_error

    except subprocess.TimeoutExpired:
        print(f"[!] Timeout expired while parsing {filepath}")
        # Re-raise or handle as needed - potentially a server issue (5xx) or maybe 400?
        raise TimeoutError(f"Parsing timeout for {filepath}") from TimeoutExpired

    except Exception as e:
        # Catch any other unexpected errors during subprocess run or feature extraction
        print(f"[!] Unexpected Error in extract_features_from_pdf for {filepath}: {e}")
        print(traceback.format_exc()) # Print full traceback
        # Re-raise for the view to handle (should be 500)
        raise e from e

    # Return the features dictionary (might be partially filled if errors occurred but weren't raised)
    return features
